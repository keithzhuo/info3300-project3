<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Project 2</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <style>
    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }

    #button-bar button {
      background-color: #4caf50;
      /* Blue */
      border: none;
      color: white;
      padding: 12px 18px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 14px;
      margin: 4px 2px;
      transition-duration: 0.4s;
      cursor: pointer;
    }

    #button-bar button {
      background-color: white;
      color: black;
      border: 2px solid #007599;
    }

    #button-bar button:hover {
      background-color: #007599;
      color: white;
    }
  </style>
</head>

<body>
  <h1>Project 2</h1>
  <h3>Name</h3>
  Juran Li, Kefan Lu, Chuhan Yu, Hao Zhuo<br />


  <!-- Diagram 1
  <p>
  <h2>Suicide Rates per 100,000 People by Country over Years</h2>
  </p>
  <p>
  <div id="button-bar" style="margin-left: 40px"></div>
  <svg id="plot_1" height="500" width="800">
  </svg>

  <script id="plot_1">
    //   Set-up
    const svg = d3.select("#plot_1");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 30, right: 30, bottom: 120, left: 80 };
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;
    let annotations = svg.append("g").attr("id", "annotations");
    let chartArea = svg
      .append("g")
      .attr("id", "points")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    // fetch data with async function
    const requestData = async function () {
      const data = await d3.csv("suicide1.csv");

      data.forEach((d) => {
        // convert string into integers
        d["Suicide Rate"] = parseFloat(d["Suicide Rate"]) * 1000;
      });

      // x-axis: country
      const countryScale = d3
        .scaleBand()
        .domain(d3.map(data, (d) => d["Country"]))
        .range([0, chartWidth])
        .padding(0.1);
      const xAxis = d3.axisBottom().scale(countryScale);
      const xGridlines = d3
        .axisBottom(countryScale)
        .tickSize(-chartHeight - 10)
        .tickFormat("");
      console.log(countryScale("United States"));

      annotations
        .append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
        .call(xAxis)
        .selectAll("text")
        .style("font-size", "12px")
        .style("text-anchor", "end")
        .attr("dx", "-1em")
        .attr("dy", "-.50em")
        .attr("transform", "rotate(-90)");


      const suicideExtent = d3.extent(data, (d) => d["Suicide Rate"]);
      console.log(suicideExtent);
      const suicideScale = d3
        .scaleLinear()
        .domain([0, suicideExtent[1] + 5])
        .range([chartHeight, 0]);

      const yAxis = d3.axisLeft().scale(suicideScale);
      const yGridlines = d3
        .axisLeft(suicideScale)
        .tickSize(-chartWidth)
        .tickFormat("");

      annotations
        .append("g")
        .attr("class", "y axis")
        .attr("transform", `translate(${margin.left - 10},${margin.top})`)
        .call(yAxis)
        .selectAll("text")
        .style("font-size", "12px");

      annotations
        .append("g")
        .attr("class", "y gridlines")
        .attr("transform", `translate(${margin.left},${margin.top})`)
        .call(yGridlines);

      annotations.append("text") // y axis lable
        .attr("class", "y label")
        .attr("font-size", "14px")
        .attr("text-anchor", "middle")
        .attr("transform", `translate(${margin.left - 10},${margin.top + chartHeight / 2}) translate(-45, 0) rotate(-90)`)
        .style("font-weight", "bold")
        .text("Suicide Rates per 100,000 People (Number of Deaths)");


      function updateBarsByYear(yearKey) {
        const yearData = data.filter((d) => {
          return d["Year"] === yearKey;
        });
        console.log(yearData);

        chartArea
          .selectAll("rect.bar")
          .data(yearData)
          .join(
            (enter) =>
              enter
                .append("rect")
                .attr("class", "bar")
                .attr("fill", "#007599")
                .attr("stroke", "black")
                .attr("stroke-width", 1)
                .attr("x", (d) => countryScale(d["Country"]))
                .attr("y", (d) => suicideScale(d["Suicide Rate"]))
                .attr(
                  "height",
                  (d) => suicideScale(0) - suicideScale(d["Suicide Rate"])
                )
                .attr("width", countryScale.bandwidth())
                .attr("opacity", 0)
                .call((enter) => enter.transition().attr("opacity", 1)),
            (update) =>
              update.call((update) =>
                update
                  .transition()
                  .attr("fill", "#007599")
                  .attr("stroke", "black")
                  .attr("stroke-width", 1)
                  .attr("x", (d) => countryScale(d["Country"]))
                  .attr("y", (d) => suicideScale(d["Suicide Rate"]))
                  .attr(
                    "height",
                    (d) => suicideScale(0) - suicideScale(d["Suicide Rate"])
                  )
                  .attr("width", countryScale.bandwidth())
              ),
            (exit) =>
              exit.call((exit) =>
                exit.transition().attr("opacity", 0).remove()
              )
          );
      }

      //  add interactvity with GDP
      const gdpExtent = d3.extent(data, (d) =>
        parseInt(d["Average of gdp_per_capita ($)"])
      );

      // add legend
      const gdpCut = [20000];

      colorLegend = [[0, "#007599"], [1, "#8d3527"]]
      colorLegendLabel = [[0, "high"], [1, "low"]]
      // color legend
      svg
        .selectAll("colorlegend")
        .data(colorLegend)
        .enter()
        .append("rect")
        .attr("x", d => 630 + d[0] * 80)
        .attr("y", 20)
        .attr("width", 15)
        .attr("height", 15)
        .style("fill", d => d[1]);
      // color legend label
      svg
        .selectAll("colorlegendlabel")
        .data(colorLegendLabel)
        .enter()
        .append("text")
        .attr("x", d => 650 + d[0] * 80)
        .attr("y", 30)
        .style("fill", "black")
        .style("font-weight", "bold")
        .style("font-size", "12px")
        .text(d => d[1]);
      // hover prompt
      svg
        .selectAll("labelbox")
        .data(gdpCut)
        .enter()
        .append("rect")
        .attr("x", 250)
        .attr("y", 15)
        .attr("rx", 5)
        .attr("width", 370)
        .attr("height", 25)
        .style("fill", "white")
        .style("stroke", "#007599");
      const textLegend = svg
        .selectAll("labels")
        .data(gdpCut)
        .enter()
        .append("text")
        .attr("id", "contrast")
        .attr("x", 610)
        .attr("y", 30)
        .style("fill", "black")
        .style("font-weight", "bold")
        .style("font-size", "15px")
        .text("HOVER HERE to see high-low gdp countries contrast")
        .attr("text-anchor", "end")
        .style("alignment-baseline", "middle");

      const bars = chartArea.selectAll("rect.bar");

      // add hover effect
      textLegend.on("mouseover", function () {
        chartArea
          .selectAll("rect.bar")
          .filter((d) => d["Average of gdp_per_capita ($)"] < gdpCut[0])
          .attr("fill", "#8d3527")
          .transition()
          .duration(200);
      });
      textLegend.on("mouseout", function () {
        chartArea
          .selectAll("rect.bar")
          .filter((d) => d["Average of gdp_per_capita ($)"] < gdpCut[0])
          .attr("fill", "#007599")
          .transition()
          .duration(200);
      });

      // initialize the graph with 2006 data
      updateBarsByYear("2006");
      let year_domain = [];
      data.forEach((d, i) => {
        year_domain.push(d["Year"]);
      });
      year_domain = [...new Set(year_domain)];
      year_domain.forEach((d) => {
        d3.select("div#button-bar")
          .append("button")
          .text(d)
          .on("click", function () {
            updateBarsByYear(d);
          });
      });
    };

    requestData();
  </script>
  </p> -->





  <!-- Diagram 2 -->

  <h2> World Food Price Choropleth Map </h2>
  <p id="P2">
  <div id="dropdown1">Select Diet: </div>
  <div id="dropdown2">Select Affordability Metric: </div>
  <div>
    <svg id="choropleth" height="770" width="990" style="margin:20px"></svg>
  </div>
  <div>
    <svg id="colorLegend" height="100" width="990" style="margin:20px"></svg>
  </div>
  <script>
    const svg2 = d3.select("#choropleth");
    const width2 = svg2.attr("width");
    const height2 = svg2.attr("height");
    const margin2 = { top: 20, right: 20, bottom: 20, left: 20 };
    const mapWidth = width2 - margin2.left - margin2.right;
    const mapHeight = height2 - margin2.top - margin2.bottom;
    const map = svg2.append("g")
      .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

    // async function to draw a map based on the selected yearKey and type of metric
    const requestData2 = async function (diet, metric) {
      const data = await d3.json("110m.json");
      // adjust data to ingest, target metric, and color range
      fp = await d3.csv(diet + " " + metric + ".csv");
      target = 'target';
      colorRange = ["#00ffff", "#00cfe3", "#00a1c1", "#007599", "#004c6d"]
      //subset the data based on selected yearKey
      yearData = fp;

      //access the metric from a separate dataset and add it as one attribute of each datum to the topojson.
      rateByCountry = {};
      rates = [];
      yearData.forEach(function (d) {
        rateByCountry[d.Entity] = +d[target];
        rates.push(d[target])
      });
      data.objects.countries.geometries.forEach(function (d) { d.properties.rate = rateByCountry[d.properties.name] || 0 });

      const colorScale = d3.scaleQuantile()
        .domain(rates)
        .range(colorRange);

      // create countries and countries mesh to plot the map 
      var countries = topojson.feature(data, data.objects.countries);
      var countriesMesh = topojson.mesh(data, data.objects.countries);
      var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], countries);
      var path = d3.geoPath().projection(projection);
      map.selectAll("path.country").data(countries.features)
        .join("path")
        .attr("class", "country")
        .attr("d", path)
        .style("fill", d => colorScale(d.properties.rate))
        .attr("rate", d => d.properties.rate)
        .attr("name", d => d.properties.name)
        .on('mouseover', mouseEntersPlot)
        .on('mouseout', mouseLeavesPlot);

      map.append("path").datum(countriesMesh)
        .attr("class", "zoutline")
        .attr("stroke", "white")
        .attr("stroke-width", "1px")
        .attr("fill", "none")
        .attr("d", path);

      // add tooltips for the map (credit to Prof Jeff Rzeszotarski)
      let tooltipWidth = 200;
      let tooltipHeight = 40;


      let momesh = map.append("path")
        .attr("class", "mouseover outline")
        .attr("d", "");

      let tooltip = map.append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");

      tooltip.append("rect")
        .attr("fill", "black")
        .attr("opacity", 0.9)
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight)
      let txt = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 2);
      let txt2 = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 22);

      // make them to appear as one hovers the mouse on a country
      d3.selectAll(".country").on("mouseenter", mouseEntersPlot);
      d3.selectAll(".country").on("mouseout", mouseLeavesPlot);

      // clears previous legend whenever this function creates a new map
      var prevLegend = d3.select("svg#colorLegend");
      prevLegend.selectAll("*").remove();
      // draw a new legend 
      drawLegend(d3.select("#colorLegend"), colorScale);


      // functions to make the tooltips appear when cursor hovers over a country and disappear when it moves away (credit to Prof Jeff Rzeszotarski)
      function mouseEntersPlot() {
        tooltip.style("visibility", "visible")
        let country = d3.select(this);
        let countryID = country.datum().properties.name;
        let countryRate = country.datum().properties.rate;
        console.log(country.datum().properties.name)

        txt.text(countryID);
        txt2.text(roundToTwo(countryRate));
        let bounds = path.bounds(country.datum());
        let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
        let yPos = bounds[1][1] - 15;
        tooltip.attr("transform", `translate(${xPos},${yPos})`);
        var mo = topojson.mesh(data, data.objects.countries, function (a, b) { return a.id === countryID || b.id === countryID; });
        momesh.datum(mo).attr("d", path)
      }

      function mouseLeavesPlot() {
        tooltip.style("visibility", "hidden");
        let state = d3.select(this);
        momesh.attr("d", "");

      }

    };

    function roundToTwo(num) {
      return +(Math.round(num + "e+2") + "e-2");
    }

    // Parameters to create a default map when landing on the page
    selectedOption1 = 'Healthy diet'
    selectedOption2 = 'Share that cannot afford'
    requestData2(selectedOption1, selectedOption2);

    // add all metrics available
    const typeKeys = ['Healthy diet', 'Nutritionally adequate', 'Calorie sufficient'];
    const metricKeys = ['Share that cannot afford', 'Number that cannot afford'];

    // add dropdown to select diet  
    var dropdownButton = d3.select("div#dropdown1")
      .append('select')

    dropdownButton
      .selectAll('myOptions')
      .data(typeKeys)
      .enter()
      .append('option')
      .text(function (d) { return d; })
      .attr("value", function (d) { return d; })

    dropdownButton.on("change", function (d) {

      selectedOption1 = d3.select(this).property("value")
      requestData2(selectedOption1, selectedOption2)
    })

    // add dropdown to select affordability metric
    var dropdownButton2 = d3.select("div#dropdown2")
      .append('select')

    dropdownButton2
      .selectAll('myOptions')
      .data(metricKeys)
      .enter()
      .append('option')
      .text(function (d) { return d; })
      .attr("value", function (d) { return d; })

    dropdownButton2.on("change", function (d) {
      selectedOption2 = d3.select(this).property("value")
      requestData2(selectedOption1, selectedOption2)
    })


    // Function to draw legend (credit to Prof Jeff Rzeszotarski)
    function drawLegend(legend, legendColorScale) {
      const legendWidth = legend.attr("width");
      const legendHeight = legend.attr("height");
      const legendMinMax = d3.extent(legendColorScale.domain()); // way to recover the minMax from most kinds of scales
      const barHeight = 60;
      const stepSize = 4; // warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance
      const pixelScale = d3.scaleLinear().domain([0, legendWidth - 40]).range([legendMinMax[0] - 1, legendMinMax[1] + 1]); // In this case the "data" are pixels, and we get numbers to use in colorScale
      const barScale = d3.scaleLinear().domain([legendMinMax[0] - 1, legendMinMax[1] + 1]).range([0, legendWidth - 40]);
      const barAxis = d3.axisBottom(barScale);
      console.log(barAxis.tickValues(legendColorScale.quantiles().concat(legendMinMax)))
      if (legendColorScale.hasOwnProperty('quantiles')) {
        // Use the quantile breakpoints plus the min and max of the scale as tick values
        barAxis.tickValues(legendColorScale.quantiles().concat(legendMinMax)).tickFormat(function (d) {
          return d3.format(".1f")(d);
        });
      }
      legend.append("g")
        .attr("class", "colorbar axis")
        .attr("transform", "translate(" + (20) + "," + (barHeight + 5) + ")")
        .call(barAxis);
      // Draw rects of color down the bar
      let bar = legend.append("g").attr("transform", "translate(" + (20) + "," + (0) + ")")
      for (let i = 0; i < legendWidth - 40; i = i + stepSize) {
        bar.append("rect")
          .attr("x", i)
          .attr("y", 0)
          .attr("width", stepSize)
          .attr("height", barHeight)
          .style("fill", legendColorScale(pixelScale(i))); // pixels => countData => color
      }
      bar.append("line").attr("stroke", "white").attr("stroke-width", 3).attr("x1", barScale(legendMinMax[0])).attr("x2", barScale(legendMinMax[0])).attr("y1", 0).attr("y1", barHeight + 4);
      bar.append("line").attr("stroke", "white").attr("stroke-width", 3).attr("x1", barScale(legendMinMax[1])).attr("x2", barScale(legendMinMax[1])).attr("y1", 0).attr("y1", barHeight + 4);

    }

  </script>
  <div id="button-bar">
  </div>
  </p>

</body>

</html>